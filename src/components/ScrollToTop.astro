---
/**
 * ScrollToTop - Subtle floating button with Reading Progress Ring
 *
 * Features:
 * - Circular progress indicator showing reading position
 * - Throttled scroll handler using requestAnimationFrame
 * - Smooth scroll animation
 * - AbortController for proper cleanup
 */
---

<button
  id="scroll-to-top"
  class="scroll-to-top"
  aria-label="Scroll to top"
  title="Back to top"
>
  <!-- Progress Ring SVG -->
  <svg
    class="progress-ring"
    width="44"
    height="44"
    viewBox="0 0 44 44"
    fill="none"
  >
    <circle
      class="progress-ring__circle"
      stroke="currentColor"
      stroke-width="2"
      fill="transparent"
      r="20"
      cx="22"
      cy="22"></circle>
  </svg>

  <!-- Arrow Icon -->
  <svg
    class="arrow-icon"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
  >
    <path d="M12 19V5M5 12l7-7 7 7"></path>
  </svg>
</button>

<style>
  .scroll-to-top {
    position: fixed;
    bottom: var(--space-8);
    right: var(--space-8);
    width: var(--space-11);
    height: var(--space-11);
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--color-surface);
    border: none; /* Border replaced by the ring */
    border-radius: var(--radius-round);
    color: var(--color-muted);
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transform: translateY(var(--space-2-5));
    transition:
      opacity var(--duration-slow) var(--ease-out),
      visibility var(--duration-slow) var(--ease-out),
      transform var(--duration-slow) var(--ease-out),
      color var(--duration-normal) var(--ease-out);
    z-index: var(--z-fixed);
    padding: 0;
  }

  .scroll-to-top:focus-visible {
    outline: var(--ui-focus-ring);
    outline-offset: var(--space-0-5);
  }

  .scroll-to-top.is-visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }

  /* Progress Ring Styling */
  .progress-ring {
    position: absolute;
    top: 0;
    left: 0;
    transform: rotate(-90deg); /* Start from top */
    color: var(--color-primary);
  }

  .progress-ring__circle {
    transition: stroke-dashoffset 0.1s linear; /* Smooth fill */
    /* stroke-dasharray and stroke-dashoffset set dynamically by JS */
    stroke-linecap: round;
  }

  /* Arrow Styling */
  .arrow-icon {
    width: var(--space-5);
    height: var(--space-5);
    position: relative;
    z-index: var(--z-base);
    transition: transform var(--duration-normal) var(--ease-out);
  }

  .scroll-to-top:hover {
    color: var(--color-primary);
  }

  .scroll-to-top:hover .arrow-icon {
    transform: translateY(calc(var(--space-0-5) * -1));
  }

  @media (max-width: 600px) { /* @breakpoint-mobile */
    .scroll-to-top {
      bottom: var(--space-6);
      right: var(--space-6);
      width: var(--space-10);
      height: var(--space-10);
    }

    .progress-ring {
      width: var(--space-10);
      height: var(--space-10);
    }

    .progress-ring__circle {
      r: 18;
      cx: 20;
      cy: 20;
      /* stroke-dasharray and stroke-dashoffset set dynamically by JS */
    }

    .arrow-icon {
      width: var(--space-4-5);
      height: var(--space-4-5);
    }
  }
</style>

<script>
  import { onPageReady } from "../utils/lifecycle";

  const SCROLL_THRESHOLD = 200;

  onPageReady((signal) => {
    const button = document.getElementById("scroll-to-top");
    if (!button) return;

    const circle = button.querySelector(
      ".progress-ring__circle",
    ) as SVGCircleElement;

    let ticking = false;

    function getCircumference(): number {
      return circle.r.baseVal.value * 2 * Math.PI;
    }

    function applyCircumference(c: number): void {
      circle.style.strokeDasharray = `${c} ${c}`;
      circle.style.strokeDashoffset = `${c}`;
    }

    let circumference = getCircumference();
    applyCircumference(circumference);

    const updateProgress = (): void => {
      const scrollTop = window.scrollY;
      const docHeight = document.documentElement.scrollHeight;
      const winHeight = window.innerHeight;
      const scrollPercent =
        docHeight > winHeight ? scrollTop / (docHeight - winHeight) : 0;
      const offset = circumference - Math.min(scrollPercent, 1) * circumference;

      circle.style.strokeDashoffset = offset.toString();
      button.classList.toggle("is-visible", scrollTop > SCROLL_THRESHOLD);
      ticking = false;
    };

    window.addEventListener(
      "resize",
      () => {
        const c = getCircumference();
        if (c !== circumference) {
          circumference = c;
          applyCircumference(circumference);
          updateProgress();
        }
      },
      { signal, passive: true },
    );

    window.addEventListener(
      "scroll",
      () => {
        if (!ticking) {
          requestAnimationFrame(updateProgress);
          ticking = true;
        }
      },
      { signal, passive: true },
    );

    button.addEventListener(
      "click",
      () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      },
      { signal },
    );

    updateProgress();
  });
</script>
