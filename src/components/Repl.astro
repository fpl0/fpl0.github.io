---
/**
 * Repl - A fully working client-side JavaScript REPL
 *
 * Used as the empty state for pages with no content.
 * Evaluates any JavaScript in the visitor's browser.
 * Captures console.log/warn/error/info output and expression results.
 *
 * Features:
 * - Contextual message above the console
 * - Autofocus on page load
 * - Command history with Up/Down arrows
 * - Console method interception (log, warn, error, info, clear)
 * - Expression result display
 * - Error handling with stack traces
 * - Auto-scroll to latest output
 * - Respects the site's design system
 */

interface Props {
  message?: string;
}

const { message = "Nothing here yet." } = Astro.props;
---

<section class="repl-empty-state">
  <p class="repl-message">{message}</p>
  <p class="repl-submessage">In the meantime, here is a JavaScript console.</p>
  <div class="repl" id="repl">
    <div class="repl-chrome">
      <span class="repl-dot"></span>
      <span class="repl-dot"></span>
      <span class="repl-dot"></span>
      <span class="repl-chrome-label">console</span>
    </div>
    <div class="repl-body">
      <div class="repl-output" id="repl-output">
        <div class="repl-line repl-welcome">
          <span class="repl-muted">// type any javascript and press enter</span>
        </div>
      </div>
      <div class="repl-input-row">
        <span class="repl-prompt" aria-hidden="true">&gt;</span>
        <input
          type="text"
          class="repl-input"
          id="repl-input"
          autocomplete="off"
          autocorrect="off"
          autocapitalize="off"
          spellcheck="false"
          aria-label="JavaScript input"
        />
      </div>
    </div>
  </div>
</section>

<style>
  /* --- Empty state wrapper --- */

  .repl-empty-state {
    padding: var(--space-10) 0 var(--space-8);
  }

  .repl-message {
    font-family: var(--font-serif);
    font-size: var(--font-size-h3);
    font-weight: 400;
    color: var(--color-text);
    margin: 0 0 var(--space-2);
    line-height: var(--line-height-snug);
  }

  .repl-submessage {
    font-family: var(--font-sans);
    font-size: var(--font-size-sm);
    color: var(--color-text-muted);
    margin: 0 0 var(--space-8);
  }

  /* --- Terminal container --- */

  .repl {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
    max-width: 100%;
    font-family: var(--font-mono);
    font-size: var(--font-size-xxs);
    line-height: var(--line-height-relaxed);
  }

  /* --- Chrome bar (title bar) --- */

  .repl-chrome {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-3) var(--space-4);
    border-bottom: 1px solid var(--color-border);
    user-select: none;
  }

  .repl-dot {
    width: 8px;
    height: 8px;
    border-radius: var(--radius-round);
    background: var(--color-border);
  }

  .repl-chrome-label {
    margin-left: auto;
    font-family: var(--font-mono-brand);
    font-size: var(--font-size-micro);
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--color-text-muted);
  }

  /* --- Body area --- */

  .repl-body {
    padding: var(--space-4);
  }

  /* --- Output area --- */

  .repl-output {
    max-height: 20rem;
    overflow-y: auto;
    margin-bottom: var(--space-2);
    scroll-behavior: smooth;
  }

  .repl-line {
    padding: 0.1em 0;
    white-space: pre-wrap;
    word-break: break-all;
  }

  .repl-welcome {
    padding-bottom: var(--space-2);
  }

  /* --- Line types --- */

  .repl-muted {
    color: var(--color-text-muted);
  }

  .repl-cmd {
    color: var(--color-text-secondary);
  }

  .repl-cmd .repl-prompt {
    color: var(--color-primary);
    user-select: none;
    margin-right: 0.5em;
  }

  .repl-result {
    color: var(--color-accent-cool);
  }

  .repl-result::before {
    content: "\2190  ";
    color: var(--color-text-muted);
  }

  .repl-log {
    color: var(--color-text);
  }

  .repl-warn {
    color: var(--color-warn);
  }

  .repl-error {
    color: var(--color-error);
  }

  .repl-info {
    color: var(--color-accent-cool);
  }

  /* --- Input row --- */

  .repl-input-row {
    display: flex;
    align-items: center;
    gap: 0.5em;
    border-top: 1px solid var(--color-border-subtle);
    padding-top: var(--space-3);
  }

  .repl-input-row > .repl-prompt {
    color: var(--color-primary);
    user-select: none;
    flex-shrink: 0;
  }

  .repl-input {
    flex: 1;
    background: transparent;
    border: none;
    font-family: var(--font-mono);
    font-size: var(--font-size-xxs);
    color: var(--color-text);
    outline: none;
    caret-color: var(--color-primary);
    line-height: var(--line-height-relaxed);
  }

  .repl-input::placeholder {
    color: var(--color-text-muted);
    opacity: 0.5;
  }

  /* --- Scrollbar --- */

  .repl-output::-webkit-scrollbar {
    width: 4px;
  }

  .repl-output::-webkit-scrollbar-track {
    background: transparent;
  }

  .repl-output::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: var(--radius-sm);
  }

</style>

<script>
  import { onPageReady } from "../utils/lifecycle";

  onPageReady((signal) => {
    const output = document.getElementById("repl-output")!;
    const input = document.getElementById("repl-input") as HTMLInputElement | null;
    if (!output || !input) return;

    // Autofocus the input
    input.focus();

    const history: string[] = [];
    let historyIndex = -1;
    let tempInput = "";

    /** Escape HTML to prevent XSS in output */
    function escapeHtml(str: string): string {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    /** Serialize any value for display */
    function serialize(value: unknown): string {
      if (value === undefined) return "undefined";
      if (value === null) return "null";
      if (typeof value === "string") return JSON.stringify(value);
      if (typeof value === "function") {
        return value.toString().length > 100
          ? `[Function: ${value.name || "anonymous"}]`
          : value.toString();
      }
      if (value instanceof Error) {
        return `${value.name}: ${value.message}`;
      }
      if (typeof value === "object") {
        try {
          const json = JSON.stringify(value, null, 2);
          return json.length > 500 ? `${json.slice(0, 500)}...` : json;
        } catch {
          return String(value);
        }
      }
      return String(value);
    }

    /** Append a line to the output */
    function appendLine(className: string, content: string): void {
      const line = document.createElement("div");
      line.className = `repl-line ${className}`;
      line.innerHTML = content;
      output.appendChild(line);
      output.scrollTop = output.scrollHeight;
    }

    /** Execute a command */
    function execute(code: string): void {
      // Echo the command
      appendLine(
        "repl-cmd",
        `<span class="repl-prompt">&gt;</span> ${escapeHtml(code)}`,
      );

      // Intercept console methods
      const logs: { type: string; args: unknown[] }[] = [];
      const originalConsole = {
        log: console.log,
        warn: console.warn,
        error: console.error,
        info: console.info,
        clear: console.clear,
      };

      console.log = (...args: unknown[]) => {
        logs.push({ type: "log", args });
        originalConsole.log(...args);
      };
      console.warn = (...args: unknown[]) => {
        logs.push({ type: "warn", args });
        originalConsole.warn(...args);
      };
      console.error = (...args: unknown[]) => {
        logs.push({ type: "error", args });
        originalConsole.error(...args);
      };
      console.info = (...args: unknown[]) => {
        logs.push({ type: "info", args });
        originalConsole.info(...args);
      };
      console.clear = () => {
        output.innerHTML = "";
        originalConsole.clear();
      };

      let result: unknown;
      let hasError = false;

      try {
        // Use indirect eval for global scope
        result = (0, eval)(code);
      } catch (err) {
        hasError = true;
        result = err;
      }

      // Restore console
      console.log = originalConsole.log;
      console.warn = originalConsole.warn;
      console.error = originalConsole.error;
      console.info = originalConsole.info;
      console.clear = originalConsole.clear;

      // Render console output
      for (const entry of logs) {
        const text = entry.args.map((a) => serialize(a)).join(" ");
        appendLine(`repl-${entry.type}`, escapeHtml(text));
      }

      // Render result or error
      if (hasError) {
        const err = result instanceof Error ? result : new Error(String(result));
        appendLine("repl-error", escapeHtml(`${err.name}: ${err.message}`));
      } else if (result !== undefined) {
        appendLine("repl-result", escapeHtml(serialize(result)));
      }
    }

    // --- Event handlers ---

    input.addEventListener(
      "keydown",
      (e: KeyboardEvent) => {
        if (e.key === "Enter" && input.value.trim()) {
          const code = input.value;
          history.push(code);
          historyIndex = history.length;
          tempInput = "";
          input.value = "";
          execute(code);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (historyIndex > 0) {
            if (historyIndex === history.length) {
              tempInput = input.value;
            }
            historyIndex--;
            input.value = history[historyIndex];
          }
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          if (historyIndex < history.length) {
            historyIndex++;
            input.value =
              historyIndex === history.length
                ? tempInput
                : history[historyIndex];
          }
        } else if (e.key === "l" && e.ctrlKey) {
          e.preventDefault();
          output.innerHTML = "";
        }
      },
      { signal },
    );

    // Focus input when clicking anywhere in the REPL
    const repl = document.getElementById("repl");
    repl?.addEventListener(
      "click",
      () => {
        // Don't steal focus if user is selecting text
        const selection = window.getSelection();
        if (selection && selection.toString().length > 0) return;
        input.focus();
      },
      { signal },
    );
  });
</script>
