---
/**
 * Game of Life — App Component
 *
 * Self-contained UI: canvas, floating control bar, and all client-side logic.
 * Imported by the thin page stub at src/pages/apps/game-of-life.astro.
 */
---

<canvas id="gol-canvas"></canvas>

<div class="gol-controls" id="gol-controls">
  <div class="gol-controls-left">
    <button
      class="gol-btn gol-btn-primary"
      id="gol-play"
      type="button"
      aria-label="Play"
      title="Play / Pause"
    >
      <svg class="gol-icon gol-icon-play" viewBox="0 0 24 24" fill="currentColor" stroke="none">
        <polygon points="5,3 19,12 5,21"></polygon>
      </svg>
      <svg class="gol-icon gol-icon-pause" viewBox="0 0 24 24" fill="currentColor" stroke="none">
        <rect x="6" y="4" width="4" height="16"></rect>
        <rect x="14" y="4" width="4" height="16"></rect>
      </svg>
    </button>
    <button class="gol-btn" id="gol-step" type="button" aria-label="Step" title="Advance one generation">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="5,12 12,5 19,12"></polyline>
        <line x1="12" y1="19" x2="12" y2="5"></line>
      </svg>
    </button>
  </div>

  <div class="gol-controls-center">
    <span class="gol-gen" id="gol-gen">Gen 0</span>
  </div>

  <div class="gol-controls-right">
    <label class="gol-speed-label" for="gol-speed">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <polyline points="12,6 12,12 16,14"></polyline>
      </svg>
    </label>
    <input
      class="gol-speed"
      id="gol-speed"
      type="range"
      min="1"
      max="30"
      value="10"
      aria-label="Simulation speed"
      title="Speed (generations per second)"
    />
    <button class="gol-btn" id="gol-random" type="button" aria-label="Randomize" title="Random pattern">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="2" y="2" width="8" height="8" rx="1"></rect>
        <rect x="14" y="2" width="8" height="8" rx="1"></rect>
        <rect x="2" y="14" width="8" height="8" rx="1"></rect>
        <rect x="14" y="14" width="8" height="8" rx="1"></rect>
      </svg>
    </button>
    <button class="gol-btn" id="gol-clear" type="button" aria-label="Clear" title="Clear grid">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
  </div>
</div>

<style>
  #gol-canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: crosshair;
  }

  /* --- Control Bar --- */

  .gol-controls {
    position: fixed;
    bottom: var(--space-6);
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: var(--space-4);
    padding: var(--space-2) var(--space-4);
    background: color-mix(in srgb, var(--color-surface) 85%, transparent);
    backdrop-filter: blur(var(--space-3));
    -webkit-backdrop-filter: blur(var(--space-3));
    border: var(--space-px) solid var(--color-border);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-lg);
    z-index: var(--z-sticky);
    transition:
      background var(--duration-normal) var(--ease-out),
      border-color var(--duration-normal) var(--ease-out);
  }

  .gol-controls-left,
  .gol-controls-right {
    display: flex;
    align-items: center;
    gap: var(--space-2);
  }

  .gol-controls-center {
    display: flex;
    align-items: center;
  }

  /* --- Buttons --- */

  .gol-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--space-9);
    height: var(--space-9);
    background: transparent;
    border: var(--space-px) solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-secondary);
    cursor: pointer;
    transition:
      color var(--duration-normal) var(--ease-out),
      border-color var(--duration-normal) var(--ease-out),
      background var(--duration-normal) var(--ease-out);
  }

  .gol-btn:hover {
    color: var(--color-primary);
    border-color: var(--color-primary);
    background: var(--color-highlight);
  }

  .gol-btn svg {
    width: var(--space-4);
    height: var(--space-4);
  }

  .gol-btn-primary {
    background: var(--color-highlight);
    border-color: var(--color-border);
  }

  /* Play/pause icon visibility */
  .gol-icon-pause {
    display: none;
  }

  .gol-btn-primary.is-playing .gol-icon-play {
    display: none;
  }

  .gol-btn-primary.is-playing .gol-icon-pause {
    display: block;
  }

  /* --- Generation Counter --- */

  .gol-gen {
    font-family: var(--font-mono-brand);
    font-size: var(--font-size-xxs);
    font-variant-numeric: tabular-nums;
    letter-spacing: var(--letter-spacing-loose);
    color: var(--color-text-muted);
    min-width: 6rem;
    text-align: center;
    white-space: nowrap;
  }

  /* --- Speed Slider --- */

  .gol-speed-label {
    display: flex;
    align-items: center;
    color: var(--color-text-muted);
  }

  .gol-speed-label svg {
    width: 14px;
    height: 14px;
  }

  .gol-speed {
    width: var(--space-16);
    height: var(--space-1);
    appearance: none;
    -webkit-appearance: none;
    background: var(--color-border);
    border-radius: var(--radius-sm);
    outline: none;
    cursor: pointer;
  }

  .gol-speed::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    background: var(--color-text-secondary);
    border-radius: var(--radius-round);
    cursor: pointer;
    transition: background var(--duration-normal) var(--ease-out);
  }

  .gol-speed::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: var(--color-text-secondary);
    border: none;
    border-radius: var(--radius-round);
    cursor: pointer;
    transition: background var(--duration-normal) var(--ease-out);
  }

  .gol-speed:hover::-webkit-slider-thumb {
    background: var(--color-primary);
  }

  .gol-speed:hover::-moz-range-thumb {
    background: var(--color-primary);
  }

  /* --- Mobile --- */

  @media (max-width: 600px) {
    .gol-controls {
      bottom: var(--space-4);
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
    }

    .gol-speed {
      width: var(--space-12);
    }

    .gol-speed-label {
      display: none;
    }

    .gol-gen {
      min-width: 4.5rem;
      font-size: var(--font-size-label);
    }

    .gol-btn {
      width: var(--space-8);
      height: var(--space-8);
    }

    .gol-btn svg {
      width: 14px;
      height: 14px;
    }
  }

</style>

<script>
  import { onPageReady } from "../../../utils/lifecycle";
  import { createGrid, step, clear, randomize } from "./simulation";
  import { createRenderer } from "./renderer";
  import { attachDrawControls } from "./controls";

  /**
   * Target cell size in CSS pixels.
   * Grid dimensions are computed from available space / cell size,
   * so portrait screens get more rows and landscape screens get more columns.
   */
  const TARGET_CELL_DESKTOP = 10;
  const TARGET_CELL_MOBILE = 8;

  onPageReady((signal) => {
    const canvas = document.getElementById("gol-canvas") as HTMLCanvasElement | null;
    const playBtn = document.getElementById("gol-play") as HTMLButtonElement | null;
    const stepBtn = document.getElementById("gol-step") as HTMLButtonElement | null;
    const clearBtn = document.getElementById("gol-clear") as HTMLButtonElement | null;
    const randomBtn = document.getElementById("gol-random") as HTMLButtonElement | null;
    const speedSlider = document.getElementById("gol-speed") as HTMLInputElement | null;
    const genDisplay = document.getElementById("gol-gen") as HTMLElement | null;

    if (!canvas) return;

    // Compute grid dimensions from the container's actual size
    const container = canvas.parentElement;
    if (!container) return;
    const rect = container.getBoundingClientRect();
    const isMobile = rect.width < 600;
    const cellPx = isMobile ? TARGET_CELL_MOBILE : TARGET_CELL_DESKTOP;
    const gridW = Math.max(10, Math.floor(rect.width / cellPx));
    const gridH = Math.max(10, Math.floor(rect.height / cellPx));

    let grid = createGrid(gridW, gridH);
    let generation = 0;
    let isPlaying = false;
    let speed = 10; // generations per second
    let lastStepTime = 0;
    let animFrameId = 0;

    const renderer = createRenderer({ canvas, grid });

    // Handle window resize
    const resizeObserver = new ResizeObserver(() => {
      renderer.resize();
      renderer.draw();
    });
    resizeObserver.observe(canvas.parentElement!);
    signal.addEventListener("abort", () => resizeObserver.disconnect());

    // Handle theme changes — redraw when theme toggles
    const themeObserver = new MutationObserver(() => {
      renderer.draw();
    });
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["data-theme"],
    });
    signal.addEventListener("abort", () => themeObserver.disconnect());

    function updateGenDisplay(): void {
      if (genDisplay) genDisplay.textContent = `Gen ${generation}`;
    }

    function redraw(): void {
      renderer.draw();
      updateGenDisplay();
    }

    // Drawing controls
    attachDrawControls({
      canvas,
      grid,
      renderer,
      signal,
      onDraw: () => renderer.draw(),
    });

    // Step the simulation — copies new cell state into the existing grid
    // so all references (renderer, controls) stay valid.
    function doStep(): void {
      const next = step(grid);
      grid.cells.set(next.cells);
      generation++;
    }

    // Simulation loop — runs at the configured speed via requestAnimationFrame
    function gameLoop(timestamp: number): void {
      if (!isPlaying) return;

      const interval = 1000 / speed;
      if (timestamp - lastStepTime >= interval) {
        doStep();
        renderer.draw();
        updateGenDisplay();
        lastStepTime = timestamp;
      }

      animFrameId = requestAnimationFrame(gameLoop);
    }

    function startPlaying(): void {
      isPlaying = true;
      playBtn?.classList.add("is-playing");
      playBtn?.setAttribute("aria-label", "Pause");
      lastStepTime = performance.now();
      animFrameId = requestAnimationFrame(gameLoop);
    }

    function stopPlaying(): void {
      isPlaying = false;
      playBtn?.classList.remove("is-playing");
      playBtn?.setAttribute("aria-label", "Play");
      if (animFrameId) cancelAnimationFrame(animFrameId);
    }

    // Clean up animation frame on abort
    signal.addEventListener("abort", () => {
      if (animFrameId) cancelAnimationFrame(animFrameId);
    });

    // --- Button handlers ---

    playBtn?.addEventListener(
      "click",
      () => {
        if (isPlaying) {
          stopPlaying();
        } else {
          startPlaying();
        }
      },
      { signal },
    );

    stepBtn?.addEventListener(
      "click",
      () => {
        if (isPlaying) stopPlaying();
        doStep();
        redraw();
      },
      { signal },
    );

    clearBtn?.addEventListener(
      "click",
      () => {
        if (isPlaying) stopPlaying();
        clear(grid);
        generation = 0;
        redraw();
      },
      { signal },
    );

    randomBtn?.addEventListener(
      "click",
      () => {
        if (isPlaying) stopPlaying();
        randomize(grid, 0.3);
        generation = 0;
        redraw();
      },
      { signal },
    );

    speedSlider?.addEventListener(
      "input",
      () => {
        speed = Number.parseInt(speedSlider.value, 10);
      },
      { signal },
    );

    // Keyboard shortcuts
    window.addEventListener(
      "keydown",
      (e: KeyboardEvent) => {
        // Don't intercept when typing in input fields
        if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;

        switch (e.key) {
          case " ":
            e.preventDefault();
            if (isPlaying) stopPlaying();
            else startPlaying();
            break;
          case "n":
          case "N":
            if (isPlaying) stopPlaying();
            doStep();
            redraw();
            break;
          case "c":
          case "C":
            if (isPlaying) stopPlaying();
            clear(grid);
            generation = 0;
            redraw();
            break;
          case "r":
          case "R":
            if (isPlaying) stopPlaying();
            randomize(grid, 0.3);
            generation = 0;
            redraw();
            break;
        }
      },
      { signal },
    );

    // Initial draw
    renderer.draw();
    updateGenDisplay();
  });
</script>
