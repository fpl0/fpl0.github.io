---
/**
 * MermaidDiagram - Renders Mermaid diagrams from code blocks
 *
 * Detects ```mermaid code blocks in .content and renders them as SVG.
 * Dynamically imports mermaid so there's zero cost on pages without diagrams.
 * Respects current theme (dark/light) and re-renders on theme change.
 * Includes a "source" toggle to view the raw mermaid definition.
 */
---

<script>
  import { onPageReady } from "../utils/lifecycle";

  const FONT_FAMILY = "'Inter Variable', 'Inter Fallback', system-ui, sans-serif";

  function getMermaidConfig() {
    const isDark =
      document.documentElement.getAttribute("data-theme") !== "light";

    // Use mermaid "base" theme with custom themeVariables that map
    // to the site's warm color palette (HSL values from global.css)
    // Dark: surface is hsl(20,12%,12%), so nodes at 19% give ~7% lift —
    // enough to read as distinct shapes without harsh contrast.
    // Lines at 50% sit midway between text (87%) and muted (52%).
    const themeVariables = isDark
      ? {
          fontFamily: FONT_FAMILY,
          fontSize: "var(--space-3-5)",
          primaryColor: "hsl(20, 10%, 19%)",
          primaryTextColor: "hsl(35, 12%, 87%)",
          primaryBorderColor: "hsl(20, 10%, 28%)",
          secondaryColor: "hsl(35, 15%, 17%)",
          secondaryTextColor: "hsl(35, 12%, 87%)",
          secondaryBorderColor: "hsl(20, 10%, 26%)",
          tertiaryColor: "hsl(20, 10%, 15%)",
          tertiaryTextColor: "hsl(30, 8%, 68%)",
          tertiaryBorderColor: "hsl(20, 10%, 22%)",
          lineColor: "hsl(30, 10%, 50%)",
          textColor: "hsl(35, 12%, 87%)",
          mainBkg: "hsl(20, 10%, 19%)",
          nodeBorder: "hsl(20, 10%, 28%)",
          clusterBkg: "hsl(20, 10%, 14%)",
          clusterBorder: "hsl(20, 10%, 24%)",
          titleColor: "hsl(42, 52%, 76%)",
          edgeLabelBackground: "hsl(20, 12%, 12%)",
          nodeTextColor: "hsl(35, 12%, 87%)",
          actorTextColor: "hsl(35, 12%, 87%)",
          actorBorder: "hsl(20, 10%, 28%)",
          actorBkg: "hsl(20, 10%, 19%)",
          activationBorderColor: "hsl(42, 35%, 58%)",
          activationBkgColor: "hsl(35, 15%, 17%)",
          signalColor: "hsl(35, 12%, 87%)",
          labelBoxBkgColor: "hsl(20, 10%, 19%)",
          labelBoxBorderColor: "hsl(20, 10%, 28%)",
          labelTextColor: "hsl(35, 12%, 87%)",
          loopTextColor: "hsl(30, 8%, 68%)",
          noteBkgColor: "hsl(35, 15%, 17%)",
          noteBorderColor: "hsl(42, 35%, 58%)",
          noteTextColor: "hsl(35, 12%, 87%)",
        }
      : {
          fontFamily: FONT_FAMILY,
          fontSize: "var(--space-3-5)",
          primaryColor: "hsl(45, 35%, 90%)",
          primaryTextColor: "hsl(25, 30%, 18%)",
          primaryBorderColor: "hsl(35, 25%, 72%)",
          secondaryColor: "hsl(45, 40%, 92%)",
          secondaryTextColor: "hsl(25, 30%, 18%)",
          secondaryBorderColor: "hsl(35, 25%, 75%)",
          tertiaryColor: "hsl(45, 30%, 94%)",
          tertiaryTextColor: "hsl(25, 25%, 35%)",
          tertiaryBorderColor: "hsl(35, 25%, 80%)",
          lineColor: "hsl(25, 18%, 50%)",
          textColor: "hsl(25, 30%, 18%)",
          mainBkg: "hsl(45, 35%, 90%)",
          nodeBorder: "hsl(35, 25%, 72%)",
          clusterBkg: "hsl(45, 35%, 95%)",
          clusterBorder: "hsl(35, 25%, 80%)",
          titleColor: "hsl(28, 80%, 38%)",
          edgeLabelBackground: "hsl(45, 30%, 93%)",
          nodeTextColor: "hsl(25, 30%, 18%)",
          actorTextColor: "hsl(25, 30%, 18%)",
          actorBorder: "hsl(35, 25%, 72%)",
          actorBkg: "hsl(45, 35%, 90%)",
          activationBorderColor: "hsl(28, 60%, 48%)",
          activationBkgColor: "hsl(45, 40%, 92%)",
          signalColor: "hsl(25, 30%, 18%)",
          labelBoxBkgColor: "hsl(45, 35%, 90%)",
          labelBoxBorderColor: "hsl(35, 25%, 72%)",
          labelTextColor: "hsl(25, 30%, 18%)",
          loopTextColor: "hsl(25, 25%, 35%)",
          noteBkgColor: "hsl(45, 40%, 92%)",
          noteBorderColor: "hsl(28, 60%, 48%)",
          noteTextColor: "hsl(25, 30%, 18%)",
        };

    return {
      startOnLoad: false,
      theme: "base" as const,
      fontFamily: FONT_FAMILY,
      themeVariables,
    };
  }

  onPageReady((signal) => {
    const pres = document.querySelectorAll<HTMLPreElement>(
      '.content pre[data-language="mermaid"]',
    );
    if (pres.length === 0) return;

    interface DiagramEntry {
      rendered: HTMLDivElement;
      source: string;
      sourceBlock: HTMLPreElement;
      toggleBtn: HTMLButtonElement;
    }

    const diagrams: DiagramEntry[] = [];

    pres.forEach((pre) => {
      const code = pre.querySelector("code");
      if (!code) return;

      const source = code.textContent ?? "";

      const container = document.createElement("div");
      container.className = "mermaid-container";

      const rendered = document.createElement("div");
      rendered.className = "mermaid-rendered";

      const sourceBlock = document.createElement("pre");
      sourceBlock.className = "mermaid-source code-processed";
      sourceBlock.hidden = true;
      const sourceCode = document.createElement("code");
      sourceCode.textContent = source;
      sourceBlock.appendChild(sourceCode);

      const toggleBtn = document.createElement("button");
      toggleBtn.className = "mermaid-toggle";
      toggleBtn.setAttribute("aria-label", "View diagram source");
      toggleBtn.textContent = "source";

      toggleBtn.addEventListener("click", () => {
        const showing = !sourceBlock.hidden;
        sourceBlock.hidden = showing;
        rendered.style.display = showing ? "" : "none";
        toggleBtn.classList.toggle("is-active", !showing);
        toggleBtn.setAttribute(
          "aria-label",
          showing ? "View diagram source" : "View rendered diagram",
        );
      });

      container.appendChild(toggleBtn);
      container.appendChild(rendered);
      container.appendChild(sourceBlock);

      const target = pre.closest(".code-wrapper") ?? pre;
      target.replaceWith(container);

      diagrams.push({ rendered, source, sourceBlock, toggleBtn });
    });

    if (diagrams.length === 0) return;

    let mermaidModule: typeof import("mermaid")["default"] | null = null;
    let isRendering = false;

    async function renderAll(isThemeSwitch = false): Promise<void> {
      if (isRendering) return;
      isRendering = true;

      try {
        if (!mermaidModule) {
          const mod = await import("mermaid");
          mermaidModule = mod.default;
        }

        mermaidModule.initialize(getMermaidConfig());

        // Render into offscreen temp elements so the visible diagram
        // stays intact until the new SVG is ready
        const offscreen = document.createElement("div");
        offscreen.style.cssText =
          "position:absolute;left:-9999px;top:-9999px;visibility:hidden"; /* token-exempt */
        document.body.appendChild(offscreen);

        const tempNodes: HTMLDivElement[] = [];
        for (const { source } of diagrams) {
          const temp = document.createElement("div");
          temp.className = "mermaid";
          temp.textContent = source;
          offscreen.appendChild(temp);
          tempNodes.push(temp);
        }

        await mermaidModule.run({ nodes: tempNodes });

        // Fade out, swap SVG, fade in
        if (isThemeSwitch) {
          diagrams.forEach((d) => d.rendered.classList.add("is-swapping"));

          // Wait for fade-out transition
          await new Promise((r) => setTimeout(r, 150));
        }

        for (let i = 0; i < diagrams.length; i++) {
          const diagram = diagrams[i];
          const node = tempNodes[i];
          if (diagram && node) {
            diagram.rendered.innerHTML = node.innerHTML;
          }
        }

        if (isThemeSwitch) {
          // Force reflow before removing class so the browser sees the change
          void diagrams[0]?.rendered.offsetHeight;
          diagrams.forEach((d) => d.rendered.classList.remove("is-swapping"));
        }

        offscreen.remove();
      } finally {
        isRendering = false;
      }
    }

    // Initial render — preserve scroll position so the SVG injection
    // doesn't cause the browser to jump down to the diagram
    const savedScroll = window.scrollY;
    renderAll().then(() => {
      if (Math.abs(window.scrollY - savedScroll) > 1) {
        window.scrollTo({ top: savedScroll, behavior: "instant" });
      }
    });

    // Re-render on theme change
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (
          mutation.type === "attributes" &&
          mutation.attributeName === "data-theme"
        ) {
          renderAll(true);
          break;
        }
      }
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["data-theme"],
    });

    signal.addEventListener("abort", () => observer.disconnect());
  });
</script>
